from rich.console import Console

import pytest
console = Console()

"""
    Evaluates the pricing quotes generated by the optimized (heuristic) version of the OnChainPricingMainnet
    in contrast to its legacy version. The new version should lead to the same optimal price while consuming
    less gas.

    Tests excluded from main test suite as core functionalities are not tested here. In order to add to test 
    suite, modify the file name to: `test_heuristic_equivalency.py`. Note that tested routes depend on current
    liquidity state and, if liquidity moves between protocols, some assertions may fail.
"""

### Test findOptimalSwap Equivalencies for different cases
def test_pricing_equivalency_uniswap_v2(oneE18, weth, pricerwrapper, pricer_legacy):
  pricer = pricerwrapper
  token = "0xf0f9d895aca5c8678f706fb8216fa22957685a13" # some swap (CULTDAO-WETH) only in Uniswap V2  
  ## 1e18
  sell_count = 100000000
  sell_amount = sell_count * oneE18 
  
  tx = pricer.unsafeFindExecutableSwap(token, weth.address, sell_amount)
  assert tx[1][0] == 1 ## UNIV2  
  quote = tx[1][1]

  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert tx2.return_value[0] == 1 ## UNIV2  
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx[0] > 0 and tx[0] < tx2.gas_used ## There might some extra overhead using feed oracle in pricer for simple case with Uniswap V2

def test_pricing_equivalency_uniswap_v2_sushi(oneE18, weth, pricerwrapper, pricer_legacy):
  pricer = pricerwrapper
  token = "0x2e9d63788249371f1DFC918a52f8d799F4a38C94" # some swap (TOKE-WETH) only in Uniswap V2 & SushiSwap
  ## 1e18
  sell_count = 5000
  sell_amount = sell_count * oneE18 ## 1e18
  
  tx = pricer.unsafeFindExecutableSwap(token, weth.address, sell_amount)
  assert (tx[1][0] == 1 or tx[1][0] == 2) ## UNIV2 or SUSHI
  quote = tx[1][1]

  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert (tx2.return_value[0] == 1 or tx2.return_value[0] == 2) ## UNIV2 or SUSHI
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Note the price feed in new version might cause some nuance there
  assert tx[0] > 0 and tx[0] < tx2.gas_used

def test_pricing_equivalency_balancer_v2(oneE18, weth, aura, pricerwrapper, pricer_legacy):
  pricer = pricerwrapper
  token = aura # some swap (AURA-WETH) only in Balancer V2
  ## 1e18
  sell_count = 15000
  sell_amount = sell_count * oneE18 ## 1e18
  
  tx = pricer.unsafeFindExecutableSwap(token, weth.address, sell_amount)
  assert tx[1][0] == 5 ## BALANCER  
  quote = tx[1][1]

  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert tx2.return_value[0] == 5 ## BALANCER  
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx[0] > 0 and tx[0] < tx2.gas_used

def test_pricing_equivalency_balancer_v2_with_weth(oneE18, wbtc, aura, pricerwrapper, pricer_legacy):
  pricer = pricerwrapper
  token = aura # some swap (AURA-WETH-WBTC) only in Balancer V2 via WETH in between as connector
  ## 1e18
  sell_count = 15000
  sell_amount = sell_count * oneE18 ## 1e18

  tx = pricer.unsafeFindExecutableSwap(token, wbtc.address, sell_amount)
  assert tx[1][0] == 6 ## BALANCERWITHWETH   
  quote = tx[1][1]

  tx2 = pricer_legacy.findOptimalSwap(token, wbtc.address, sell_amount)
  assert tx2.return_value[0] == 6 ## BALANCERWITHWETH    
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx[0] > 0 and tx[0] < tx2.gas_used

def test_pricing_equivalency_uniswap_v3(oneE18, weth, pricerwrapper, pricer_legacy):
  pricer = pricerwrapper
  token = "0xf4d2888d29D722226FafA5d9B24F9164c092421E" # some swap (LOOKS-WETH) only in Uniswap V3
  ## 1e18
  sell_count = 600000
  sell_amount = sell_count * oneE18 ## 1e18
  
  tx = pricer.unsafeFindExecutableSwap(token, weth.address, sell_amount)
  assert tx[1][0] == 3 ## UNIV3   
  quote = tx[1][1]

  tx2 = pricer_legacy.findOptimalSwap(token, weth.address, sell_amount)
  assert tx2.return_value[0] == 3 ## UNIV3    
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better
  assert tx[0] > 0 and tx[0] < tx2.gas_used

def test_pricing_equivalency_uniswap_v3_with_weth(oneE18, wbtc, pricerwrapper, pricer_legacy):
  pricer = pricerwrapper
  token = "0xf4d2888d29D722226FafA5d9B24F9164c092421E" # some swap (LOOKS-WETH-WBTC) only in Uniswap V3 via WETH in between as connector
  ## 1e18
  sell_count = 600000
  sell_amount = sell_count * oneE18 ## 1e18

  tx = pricer.unsafeFindExecutableSwap(token, wbtc.address, sell_amount)
  assert tx[1][0] == 4 ## UNIV3WITHWETH  
  quote = tx[1][1]

  tx2 = pricer_legacy.findOptimalSwap(token, wbtc.address, sell_amount)
  assert tx2.return_value[0] == 4 ## UNIV3WITHWETH 
  quote_legacy = tx2.return_value[1]

  assert quote >= quote_legacy # Optimized quote must be the same or better, note the fixed pair in new version of univ3 pricer might cause some nuance there
  assert tx[0] > 0 and tx[0] < tx2.gas_used

def test_pricing_equivalency_almost_everything(oneE18, wbtc, weth, pricerwrapper, pricer_legacy):
  pricer = pricerwrapper
  token = weth # some swap (WETH-WBTC) almost in every DEX, the most gas-consuming scenario
  ## 1e18
  sell_count = 10
  sell_amount = sell_count * oneE18 ## 1e18  
  
  tx = pricer.unsafeFindExecutableSwap(token, wbtc.address, sell_amount)
  assert (tx[1][0] <= 3 or tx[1][0] == 5) ## CURVE or UNIV2 or SUSHI or UNIV3 or BALANCER  
  quote = tx[1][1]

  tx2 = pricer_legacy.findOptimalSwap(token, wbtc.address, sell_amount)
  assert (tx2.return_value[0] <= 3 or tx2.return_value[0] == 5) ## CURVE or UNIV2 or SUSHI or UNIV3 or BALANCER  
  quote_legacy = tx2.return_value[1]

  assert tx2.return_value[0] == tx[1][0]
  assert quote >= quote_legacy 
  assert tx[0] > 0 and tx[0] < tx2.gas_used


### Test specific pricing functions for different underlying protocols
def test_balancer_pricing_equivalency(oneE18, weth, usdc, pricer, pricer_legacy):  
  ## 1e18
  sell_amount = 1 * oneE18

  quote = pricer.getBalancerPriceAnalytically(weth.address, sell_amount, usdc.address)
  quote_legacy = pricer_legacy.getBalancerPrice(weth.address, sell_amount, usdc.address).return_value

  assert quote >= quote_legacy # Optimized quote must be the same or better

def test_balancer_pricing_with_connector_equivalency(wbtc, usdc, weth, pricer, pricer_legacy):  
  ## 1e8
  sell_count = 10
  sell_amount = sell_count * 100000000
    
  quote = pricer.getBalancerPriceWithConnectorAnalytically([wbtc.address, usdc.address, sell_amount, weth.address, 0, 0])
  quote_legacy = pricer_legacy.getBalancerPriceWithConnector(
    wbtc.address, 
    sell_amount, 
    usdc.address, 
    weth.address
  ).return_value

  assert quote >= quote_legacy # Optimized quote must be the same or better